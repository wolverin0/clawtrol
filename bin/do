#!/usr/bin/env ruby
# frozen_string_literal: true

require "fileutils"

# Remote server configuration
REMOTE_HOST = "104.236.193.0"
REMOTE_USER = "root"
APP_NAME = "cardy"
APP_DIR = "/var/www/#{APP_NAME}"
DB_NAME = "#{APP_NAME}_production"
DB_USER = "cardy"
BACKUP_DIR = "/var/backups/#{APP_NAME}"

# Colors for output
class Colors
  def self.green(text)
    "\e[32m#{text}\e[0m"
  end

  def self.red(text)
    "\e[31m#{text}\e[0m"
  end

  def self.yellow(text)
    "\e[33m#{text}\e[0m"
  end

  def self.blue(text)
    "\e[34m#{text}\e[0m"
  end
end

def log(message, color = :green)
  puts Colors.send(color, "===> #{message}")
end

def error(message)
  puts Colors.red("ERROR: #{message}")
  exit 1
end

def remote_exec(command, interactive: false)
  ssh_command = "ssh #{REMOTE_USER}@#{REMOTE_HOST}"
  full_command = "#{ssh_command} '#{command}'"

  if interactive
    exec full_command
  else
    log "Running: #{command}", :blue
    system(full_command) || error("Remote command failed")
  end
end

def rails_command(command, interactive: false)
  full_command = "cd #{APP_DIR} && source .env.production && RAILS_ENV=production bundle exec rails #{command}"
  remote_exec(full_command, interactive: interactive)
end

def show_usage
  puts <<~USAGE
    #{Colors.green('Usage:')} bin/do <command> [options]

    #{Colors.yellow('Database Commands:')}
      db download           Download production database to local
      db backup             Create a backup of the production database
      db restore <file>     Restore a database backup to production
      db console            Open database console on production

    #{Colors.yellow('Application Commands:')}
      console               Open Rails console on production
      logs                  Tail application logs
      ssh                   SSH into the production server
      shell                 Open shell in application container
      restart               Restart the application
      ps                    Show running containers

    #{Colors.yellow('Deployment Commands:')}
      deploy                Shows how to deploy (via GitHub Actions)

    #{Colors.yellow('Cache & Queue Commands:')}
      cache:clear           Clear the production cache
      jobs                  Show Solid Queue jobs status

    #{Colors.yellow('Examples:')}
      bin/do db download
      bin/do console
      bin/do logs
      bin/do db restore tmp/backup.sql
  USAGE
end

# Command handlers
def db_download
  log "Downloading production database..."

  # Create tmp directory if it doesn't exist
  FileUtils.mkdir_p("tmp")

  timestamp = Time.now.strftime("%Y%m%d%H%M%S")
  local_backup = "tmp/production_#{timestamp}.sql"

  log "Creating PostgreSQL dump on server..."
  remote_exec("cd #{APP_DIR} && source .env.production && PGPASSWORD=\"$DATABASE_PASSWORD\" pg_dump -U #{DB_USER} -h localhost #{DB_NAME} > /tmp/#{APP_NAME}_backup.sql")

  log "Copying database dump to local machine..."
  system("scp #{REMOTE_USER}@#{REMOTE_HOST}:/tmp/#{APP_NAME}_backup.sql #{local_backup}") || error("Failed to download database")

  if File.exist?(local_backup)
    log "Database downloaded to: #{local_backup}"
    log "To restore it locally, run:"
    puts "\n  dropdb cardy_development && createdb cardy_development"
    puts "  psql -U postgres cardy_development < #{local_backup}\n\n"
  else
    error "Failed to download database"
  end
end

def db_backup
  log "Creating production database backup..."
  timestamp = Time.now.strftime("%Y%m%d_%H%M%S")
  backup_file = "backup_#{timestamp}.sql"

  log "Creating PostgreSQL backup..."
  remote_exec("cd #{APP_DIR} && source .env.production && PGPASSWORD=\"$DATABASE_PASSWORD\" pg_dump -U #{DB_USER} -h localhost #{DB_NAME} > #{BACKUP_DIR}/#{backup_file}")
  log "Backup created on server: #{BACKUP_DIR}/#{backup_file}"

  log "Download it with:"
  puts "\n  scp #{REMOTE_USER}@#{REMOTE_HOST}:#{BACKUP_DIR}/#{backup_file} tmp/\n\n"
end

def db_restore(backup_file)
  error "Please provide a backup file path" unless backup_file
  error "Backup file not found: #{backup_file}" unless File.exist?(backup_file)

  log "WARNING: This will overwrite the production database!", :yellow
  print "Type 'yes' to continue: "
  confirmation = gets.chomp
  error "Restore cancelled" unless confirmation == "yes"

  log "Uploading backup to server..."
  system("scp #{backup_file} #{REMOTE_USER}@#{REMOTE_HOST}:/tmp/restore.sql") || error("Upload failed")

  log "Restoring from backup...", :yellow
  remote_exec("cd #{APP_DIR} && source .env.production && PGPASSWORD=\"$DATABASE_PASSWORD\" psql -U #{DB_USER} -h localhost #{DB_NAME} < /tmp/restore.sql")

  log "Running migrations..."
  rails_command("db:migrate")

  log "Database restored successfully"
end

def db_console
  log "Opening database console..."
  remote_exec("cd #{APP_DIR} && source .env.production && PGPASSWORD=\"$DATABASE_PASSWORD\" psql -U #{DB_USER} -h localhost #{DB_NAME}", interactive: true)
end

def rails_console
  log "Opening Rails console..."
  rails_command("console", interactive: true)
end

def show_logs
  log "Showing logs..."
  puts "\n#{Colors.yellow('Available logs:')}"
  puts "  1. Puma logs: journalctl -u puma -f"
  puts "  2. Solid Queue logs: journalctl -u solid_queue -f"
  puts "  3. Rails production log: tail -f #{APP_DIR}/log/production.log"
  puts "\n#{Colors.green('Choose which logs to tail:')} "
  print "Enter 1, 2, or 3 (or 'all' for combined): "
  choice = gets.chomp

  case choice
  when "1"
    exec "ssh #{REMOTE_USER}@#{REMOTE_HOST} 'journalctl -u puma -f'"
  when "2"
    exec "ssh #{REMOTE_USER}@#{REMOTE_HOST} 'journalctl -u solid_queue -f'"
  when "3"
    exec "ssh #{REMOTE_USER}@#{REMOTE_HOST} 'tail -f #{APP_DIR}/log/production.log'"
  when "all"
    exec "ssh #{REMOTE_USER}@#{REMOTE_HOST} 'tail -f #{APP_DIR}/log/production.log & journalctl -u puma -u solid_queue -f'"
  else
    error "Invalid choice"
  end
end

def ssh_connect
  log "Connecting to production server..."
  exec "ssh #{REMOTE_USER}@#{REMOTE_HOST}"
end

def app_shell
  log "Opening shell in application directory..."
  exec "ssh -t #{REMOTE_USER}@#{REMOTE_HOST} 'cd #{APP_DIR} && bash'"
end

def restart_app
  log "Restarting services..."
  remote_exec("systemctl restart puma")
  remote_exec("systemctl restart solid_queue")

  sleep 2
  log "Checking service status..."
  remote_exec("systemctl is-active puma && systemctl is-active solid_queue")
  log "Services restarted successfully"
end

def show_ps
  log "Showing running services..."
  remote_exec("systemctl status puma --no-pager")
  puts ""
  remote_exec("systemctl status solid_queue --no-pager")
end

def deploy
  log "Deploying via GitHub Actions..."
  log "Push to main branch to trigger deployment", :yellow
  puts "\n  git push origin main\n\n"
end

def clear_cache
  log "Clearing production cache..."
  rails_command("cache:clear")
  log "Cache cleared"
end

def show_jobs
  log "Showing Solid Queue jobs..."
  rails_command("runner 'puts \"Total jobs: #{SolidQueue::Job.count}\"'")
end

# Main command router
command = ARGV[0]
subcommand = ARGV[1]

case command
when "db"
  case subcommand
  when "download"
    db_download
  when "backup"
    db_backup
  when "restore"
    db_restore(ARGV[2])
  when "console"
    db_console
  else
    error "Unknown db command: #{subcommand}\nRun 'bin/do' for usage"
  end
when "console"
  rails_console
when "logs"
  show_logs
when "ssh"
  ssh_connect
when "shell"
  app_shell
when "restart"
  restart_app
when "ps"
  show_ps
when "deploy"
  deploy
when "cache:clear"
  clear_cache
when "jobs"
  show_jobs
when "help", "--help", "-h", nil
  show_usage
else
  error "Unknown command: #{command}\nRun 'bin/do' for usage"
end
